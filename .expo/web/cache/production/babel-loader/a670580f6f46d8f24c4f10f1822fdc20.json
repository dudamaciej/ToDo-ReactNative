{"ast":null,"code":"import{typeOf,isElement,isValidElementType}from'react-is';import React,{useState,useContext,useMemo,useEffect,useRef,createElement,useDebugValue}from'react';import shallowequal from'shallowequal';import Stylis from'@emotion/stylis';import unitless from'@emotion/unitless';import validAttr from'@emotion/is-prop-valid';import hoist from'hoist-non-react-statics';function _extends(){_extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;};return _extends.apply(this,arguments);}function _objectWithoutPropertiesLoose(source,excluded){if(source==null)return{};var target={};var sourceKeys=Object.keys(source);var key,i;for(i=0;i<sourceKeys.length;i++){key=sourceKeys[i];if(excluded.indexOf(key)>=0)continue;target[key]=source[key];}return target;}var interleave=function interleave(strings,interpolations){var result=[strings[0]];for(var i=0,len=interpolations.length;i<len;i+=1){result.push(interpolations[i],strings[i+1]);}return result;};var isPlainObject=function isPlainObject(x){return x!==null&&typeof x==='object'&&(x.toString?x.toString():Object.prototype.toString.call(x))==='[object Object]'&&!typeOf(x);};var EMPTY_ARRAY=Object.freeze([]);var EMPTY_OBJECT=Object.freeze({});function isFunction(test){return typeof test==='function';}function getComponentName(target){return(process.env.NODE_ENV!=='production'?typeof target==='string'&&target:false)||target.displayName||target.name||'Component';}function isStatelessFunction(test){return typeof test==='function'&&!(test.prototype&&test.prototype.isReactComponent);}function isStyledComponent(target){return target&&typeof target.styledComponentId==='string';}var SC_ATTR=typeof process!=='undefined'&&(process.env.REACT_APP_SC_ATTR||process.env.SC_ATTR)||'data-styled';var SC_ATTR_ACTIVE='active';var SC_ATTR_VERSION='data-styled-version';var SC_VERSION=\"5.1.0\";var SPLITTER='/*!sc*/\\n';var IS_BROWSER=typeof window!=='undefined'&&'HTMLElement'in window;var DISABLE_SPEEDY=typeof SC_DISABLE_SPEEDY==='boolean'&&SC_DISABLE_SPEEDY||typeof process!=='undefined'&&(process.env.REACT_APP_SC_DISABLE_SPEEDY||process.env.SC_DISABLE_SPEEDY)||process.env.NODE_ENV!=='production';var STATIC_EXECUTION_CONTEXT={};var getNonce=function getNonce(){return typeof __webpack_nonce__!=='undefined'?__webpack_nonce__:null;};var errorMap={\"1\":\"Cannot create styled-component for component: %s.\\n\\n\",\"2\":\"Can't collect styles once you've consumed a `ServerStyleSheet`'s styles! `ServerStyleSheet` is a one off instance for each server-side render cycle.\\n\\n- Are you trying to reuse it across renders?\\n- Are you accidentally calling collectStyles twice?\\n\\n\",\"3\":\"Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.\\n\\n\",\"4\":\"The `StyleSheetManager` expects a valid target or sheet prop!\\n\\n- Does this error occur on the client and is your target falsy?\\n- Does this error occur on the server and is the sheet falsy?\\n\\n\",\"5\":\"The clone method cannot be used on the client!\\n\\n- Are you running in a client-like environment on the server?\\n- Are you trying to run SSR on the client?\\n\\n\",\"6\":\"Trying to insert a new style tag, but the given Node is unmounted!\\n\\n- Are you using a custom target that isn't mounted?\\n- Does your document not have a valid head element?\\n- Have you accidentally removed a style tag manually?\\n\\n\",\"7\":\"ThemeProvider: Please return an object from your \\\"theme\\\" prop function, e.g.\\n\\n```js\\ntheme={() => ({})}\\n```\\n\\n\",\"8\":\"ThemeProvider: Please make your \\\"theme\\\" prop an object.\\n\\n\",\"9\":\"Missing document `<head>`\\n\\n\",\"10\":\"Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021\\n\\n\",\"11\":\"_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.\\n\\n\",\"12\":\"It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\\\`\\\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\\n\\n\",\"13\":\"%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\\n\\n\",\"14\":\"ThemeProvider: \\\"theme\\\" prop is required.\\n\\n\",\"15\":\"A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\\n\\n```js\\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\\n```\\n\\n\",\"16\":\"Reached the limit of how many styled components may be created at group %s.\\nYou may only create up to 1,073,741,824 components. If you're creating components dynamically,\\nas for instance in your render method then you may be running into this limitation.\\n\\n\",\"17\":\"CSSStyleSheet could not be found on HTMLStyleElement.\\nHas styled-components' style tag been unmounted or altered by another script?\\n\"};var ERRORS=process.env.NODE_ENV!=='production'?errorMap:{};function format(){var a=arguments.length<=0?undefined:arguments[0];var b=[];for(var c=1,len=arguments.length;c<len;c+=1){b.push(c<0||arguments.length<=c?undefined:arguments[c]);}b.forEach(function(d){a=a.replace(/%[a-z]/,d);});return a;}function throwStyledComponentsError(code){for(var _len=arguments.length,interpolations=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){interpolations[_key-1]=arguments[_key];}if(process.env.NODE_ENV==='production'){throw new Error(\"An error occurred. See https://github.com/styled-components/styled-components/blob/master/packages/styled-components/src/utils/errors.md#\"+code+\" for more information.\"+(interpolations.length>0?\" Additional arguments: \"+interpolations.join(', '):''));}else{throw new Error(format.apply(void 0,[ERRORS[code]].concat(interpolations)).trim());}}var ELEMENT_TYPE=1;var findLastStyleTag=function findLastStyleTag(target){var childNodes=target.childNodes;for(var i=childNodes.length;i>=0;i--){var child=childNodes[i];if(child&&child.nodeType===ELEMENT_TYPE&&child.hasAttribute(SC_ATTR)){return child;}}return undefined;};var makeStyleTag=function makeStyleTag(target){var head=document.head;var parent=target||head;var style=document.createElement('style');var prevStyle=findLastStyleTag(parent);var nextSibling=prevStyle!==undefined?prevStyle.nextSibling:null;style.setAttribute(SC_ATTR,SC_ATTR_ACTIVE);style.setAttribute(SC_ATTR_VERSION,SC_VERSION);var nonce=getNonce();if(nonce)style.setAttribute('nonce',nonce);parent.insertBefore(style,nextSibling);return style;};var getSheet=function getSheet(tag){if(tag.sheet){return tag.sheet;}var _document=document,styleSheets=_document.styleSheets;for(var i=0,l=styleSheets.length;i<l;i++){var sheet=styleSheets[i];if(sheet.ownerNode===tag){return sheet;}}throwStyledComponentsError(17);return undefined;};var makeTag=function makeTag(_ref){var isServer=_ref.isServer,useCSSOMInjection=_ref.useCSSOMInjection,target=_ref.target;if(isServer){return new VirtualTag(target);}else if(useCSSOMInjection){return new CSSOMTag(target);}else{return new TextTag(target);}};var CSSOMTag=function(){function CSSOMTag(target){var element=this.element=makeStyleTag(target);element.appendChild(document.createTextNode(''));this.sheet=getSheet(element);this.length=0;}var _proto=CSSOMTag.prototype;_proto.insertRule=function insertRule(index,rule){try{this.sheet.insertRule(rule,index);this.length++;return true;}catch(_error){return false;}};_proto.deleteRule=function deleteRule(index){this.sheet.deleteRule(index);this.length--;};_proto.getRule=function getRule(index){var rule=this.sheet.cssRules[index];if(rule!==undefined&&typeof rule.cssText==='string'){return rule.cssText;}else{return'';}};return CSSOMTag;}();var TextTag=function(){function TextTag(target){var element=this.element=makeStyleTag(target);this.nodes=element.childNodes;this.length=0;}var _proto2=TextTag.prototype;_proto2.insertRule=function insertRule(index,rule){if(index<=this.length&&index>=0){var node=document.createTextNode(rule);var refNode=this.nodes[index];this.element.insertBefore(node,refNode||null);this.length++;return true;}else{return false;}};_proto2.deleteRule=function deleteRule(index){this.element.removeChild(this.nodes[index]);this.length--;};_proto2.getRule=function getRule(index){if(index<this.length){return this.nodes[index].textContent;}else{return'';}};return TextTag;}();var VirtualTag=function(){function VirtualTag(_target){this.rules=[];this.length=0;}var _proto3=VirtualTag.prototype;_proto3.insertRule=function insertRule(index,rule){if(index<=this.length){this.rules.splice(index,0,rule);this.length++;return true;}else{return false;}};_proto3.deleteRule=function deleteRule(index){this.rules.splice(index,1);this.length--;};_proto3.getRule=function getRule(index){if(index<this.length){return this.rules[index];}else{return'';}};return VirtualTag;}();var makeGroupedTag=function makeGroupedTag(tag){return new DefaultGroupedTag(tag);};var BASE_SIZE=1<<9;var DefaultGroupedTag=function(){function DefaultGroupedTag(tag){this.groupSizes=new Uint32Array(BASE_SIZE);this.length=BASE_SIZE;this.tag=tag;}var _proto=DefaultGroupedTag.prototype;_proto.indexOfGroup=function indexOfGroup(group){var index=0;for(var i=0;i<group;i++){index+=this.groupSizes[i];}return index;};_proto.insertRules=function insertRules(group,rules){if(group>=this.groupSizes.length){var oldBuffer=this.groupSizes;var oldSize=oldBuffer.length;var newSize=oldSize;while(group>=newSize){newSize<<=1;if(newSize<0){throwStyledComponentsError(16,\"\"+group);}}this.groupSizes=new Uint32Array(newSize);this.groupSizes.set(oldBuffer);this.length=newSize;for(var i=oldSize;i<newSize;i++){this.groupSizes[i]=0;}}var ruleIndex=this.indexOfGroup(group+1);for(var _i=0,l=rules.length;_i<l;_i++){if(this.tag.insertRule(ruleIndex,rules[_i])){this.groupSizes[group]++;ruleIndex++;}}};_proto.clearGroup=function clearGroup(group){if(group<this.length){var length=this.groupSizes[group];var startIndex=this.indexOfGroup(group);var endIndex=startIndex+length;this.groupSizes[group]=0;for(var i=startIndex;i<endIndex;i++){this.tag.deleteRule(startIndex);}}};_proto.getGroup=function getGroup(group){var css='';if(group>=this.length||this.groupSizes[group]===0){return css;}var length=this.groupSizes[group];var startIndex=this.indexOfGroup(group);var endIndex=startIndex+length;for(var i=startIndex;i<endIndex;i++){css+=\"\"+this.tag.getRule(i)+SPLITTER;}return css;};return DefaultGroupedTag;}();var MAX_SMI=1<<31-1;var groupIDRegister=new Map();var reverseRegister=new Map();var nextFreeGroup=1;var getGroupForId=function getGroupForId(id){if(groupIDRegister.has(id)){return groupIDRegister.get(id);}var group=nextFreeGroup++;if(process.env.NODE_ENV!=='production'&&((group|0)<0||group>MAX_SMI)){throwStyledComponentsError(16,\"\"+group);}groupIDRegister.set(id,group);reverseRegister.set(group,id);return group;};var getIdForGroup=function getIdForGroup(group){return reverseRegister.get(group);};var setGroupForId=function setGroupForId(id,group){if(group>=nextFreeGroup){nextFreeGroup=group+1;}groupIDRegister.set(id,group);reverseRegister.set(group,id);};var SELECTOR=\"style[\"+SC_ATTR+\"][\"+SC_ATTR_VERSION+\"=\\\"\"+SC_VERSION+\"\\\"]\";var MARKER_RE=new RegExp(\"^\"+SC_ATTR+\"\\\\.g(\\\\d+)\\\\[id=\\\"([\\\\w\\\\d-]+)\\\"\\\\].*?\\\"([^\\\"]*)\");var outputSheet=function outputSheet(sheet){var tag=sheet.getTag();var length=tag.length;var css='';for(var group=0;group<length;group++){var id=getIdForGroup(group);if(id===undefined)continue;var names=sheet.names.get(id);var rules=tag.getGroup(group);if(names===undefined||rules.length===0)continue;var selector=SC_ATTR+\".g\"+group+\"[id=\\\"\"+id+\"\\\"]\";var content='';if(names!==undefined){names.forEach(function(name){if(name.length>0){content+=name+\",\";}});}css+=\"\"+rules+selector+\"{content:\\\"\"+content+\"\\\"}\"+SPLITTER;}return css;};var rehydrateNamesFromContent=function rehydrateNamesFromContent(sheet,id,content){var names=content.split(',');var name;for(var i=0,l=names.length;i<l;i++){if(name=names[i]){sheet.registerName(id,name);}}};var rehydrateSheetFromTag=function rehydrateSheetFromTag(sheet,style){var parts=style.innerHTML.split(SPLITTER);var rules=[];for(var i=0,l=parts.length;i<l;i++){var part=parts[i].trim();if(!part)continue;var marker=part.match(MARKER_RE);if(marker){var group=parseInt(marker[1],10)|0;var id=marker[2];if(group!==0){setGroupForId(id,group);rehydrateNamesFromContent(sheet,id,marker[3]);sheet.getTag().insertRules(group,rules);}rules.length=0;}else{rules.push(part);}}};var rehydrateSheet=function rehydrateSheet(sheet){var nodes=document.querySelectorAll(SELECTOR);for(var i=0,l=nodes.length;i<l;i++){var node=nodes[i];if(node&&node.getAttribute(SC_ATTR)!==SC_ATTR_ACTIVE){rehydrateSheetFromTag(sheet,node);if(node.parentNode){node.parentNode.removeChild(node);}}}};var SHOULD_REHYDRATE=IS_BROWSER;var defaultOptions={isServer:!IS_BROWSER,useCSSOMInjection:!DISABLE_SPEEDY};var StyleSheet=function(){StyleSheet.registerId=function registerId(id){return getGroupForId(id);};function StyleSheet(options,globalStyles,names){if(options===void 0){options=defaultOptions;}if(globalStyles===void 0){globalStyles={};}this.options=_extends({},defaultOptions,{},options);this.gs=globalStyles;this.names=new Map(names);if(!this.options.isServer&&IS_BROWSER&&SHOULD_REHYDRATE){SHOULD_REHYDRATE=false;rehydrateSheet(this);}}var _proto=StyleSheet.prototype;_proto.reconstructWithOptions=function reconstructWithOptions(options){return new StyleSheet(_extends({},this.options,{},options),this.gs,this.names);};_proto.allocateGSInstance=function allocateGSInstance(id){return this.gs[id]=(this.gs[id]||0)+1;};_proto.getTag=function getTag(){return this.tag||(this.tag=makeGroupedTag(makeTag(this.options)));};_proto.hasNameForId=function hasNameForId(id,name){return this.names.has(id)&&this.names.get(id).has(name);};_proto.registerName=function registerName(id,name){getGroupForId(id);if(!this.names.has(id)){var groupNames=new Set();groupNames.add(name);this.names.set(id,groupNames);}else{this.names.get(id).add(name);}};_proto.insertRules=function insertRules(id,name,rules){this.registerName(id,name);this.getTag().insertRules(getGroupForId(id),rules);};_proto.clearNames=function clearNames(id){if(this.names.has(id)){this.names.get(id).clear();}};_proto.clearRules=function clearRules(id){this.getTag().clearGroup(getGroupForId(id));this.clearNames(id);};_proto.clearTag=function clearTag(){this.tag=undefined;};_proto.toString=function toString(){return outputSheet(this);};return StyleSheet;}();var SEED=5381;var phash=function phash(h,x){var i=x.length;while(i){h=h*33^x.charCodeAt(--i);}return h;};var hash=function hash(x){return phash(SEED,x);};function insertRulePlugin(insertRule){var delimiter='/*|*/';var needle=delimiter+\"}\";function toSheet(block){if(block){try{insertRule(block+\"}\");}catch(e){}}}return function ruleSheet(context,content,selectors,parents,line,column,length,ns,depth,at){switch(context){case 1:if(depth===0&&content.charCodeAt(0)===64)return insertRule(content+\";\"),'';break;case 2:if(ns===0)return content+delimiter;break;case 3:switch(ns){case 102:case 112:return insertRule(selectors[0]+content),'';default:return content+(at===0?delimiter:'');}case-2:content.split(needle).forEach(toSheet);}};}var COMMENT_REGEX=/^\\s*\\/\\/.*$/gm;function createStylisInstance(_temp){var _ref=_temp===void 0?EMPTY_OBJECT:_temp,_ref$options=_ref.options,options=_ref$options===void 0?EMPTY_OBJECT:_ref$options,_ref$plugins=_ref.plugins,plugins=_ref$plugins===void 0?EMPTY_ARRAY:_ref$plugins;var stylis=new Stylis(options);var parsingRules=[];var returnRulesPlugin=function returnRulesPlugin(context){if(context===-2){var parsedRules=parsingRules;parsingRules=[];return parsedRules;}};var parseRulesPlugin=insertRulePlugin(function(rule){parsingRules.push(rule);});var _componentId;var _selector;var _selectorRegexp;var selfReferenceReplacer=function selfReferenceReplacer(match,offset,string){if(offset>0&&string.slice(0,offset).indexOf(_selector)!==-1&&string.slice(offset-_selector.length,offset)!==_selector){return\".\"+_componentId;}return match;};var selfReferenceReplacementPlugin=function selfReferenceReplacementPlugin(context,_,selectors){if(context===2&&selectors.length&&selectors[0].lastIndexOf(_selector)>0){selectors[0]=selectors[0].replace(_selectorRegexp,selfReferenceReplacer);}};stylis.use([].concat(plugins,[selfReferenceReplacementPlugin,parseRulesPlugin,returnRulesPlugin]));function stringifyRules(css,selector,prefix,componentId){if(componentId===void 0){componentId='&';}var flatCSS=css.replace(COMMENT_REGEX,'');var cssStr=selector&&prefix?prefix+\" \"+selector+\" { \"+flatCSS+\" }\":flatCSS;_componentId=componentId;_selector=selector;_selectorRegexp=new RegExp(\"\\\\\"+_selector+\"\\\\b\",'g');return stylis(prefix||!selector?'':selector,cssStr);}stringifyRules.hash=plugins.length?plugins.reduce(function(acc,plugin){if(!plugin.name){throwStyledComponentsError(15);}return phash(acc,plugin.name);},SEED).toString():'';return stringifyRules;}var StyleSheetContext=React.createContext();var StyleSheetConsumer=StyleSheetContext.Consumer;var StylisContext=React.createContext();var StylisConsumer=StylisContext.Consumer;var masterSheet=new StyleSheet();var masterStylis=createStylisInstance();function useStyleSheet(){return useContext(StyleSheetContext)||masterSheet;}function useStylis(){return useContext(StylisContext)||masterStylis;}function StyleSheetManager(props){var _useState=useState(props.stylisPlugins),plugins=_useState[0],setPlugins=_useState[1];var contextStyleSheet=useStyleSheet();var styleSheet=useMemo(function(){var sheet=contextStyleSheet;if(props.sheet){sheet=props.sheet;}else if(props.target){sheet=sheet.reconstructWithOptions({target:props.target});}if(props.disableCSSOMInjection){sheet=sheet.reconstructWithOptions({useCSSOMInjection:false});}return sheet;},[props.disableCSSOMInjection,props.sheet,props.target]);var stylis=useMemo(function(){return createStylisInstance({options:{prefix:!props.disableVendorPrefixes},plugins:plugins});},[props.disableVendorPrefixes,plugins]);useEffect(function(){if(!shallowequal(plugins,props.stylisPlugins))setPlugins(props.stylisPlugins);},[props.stylisPlugins]);return React.createElement(StyleSheetContext.Provider,{value:styleSheet},React.createElement(StylisContext.Provider,{value:stylis},process.env.NODE_ENV!=='production'?React.Children.only(props.children):props.children));}var Keyframes=function(){function Keyframes(name,stringifyArgs){var _this=this;this.inject=function(styleSheet){if(!styleSheet.hasNameForId(_this.id,_this.name)){styleSheet.insertRules(_this.id,_this.name,masterStylis.apply(void 0,_this.stringifyArgs));}};this.toString=function(){return throwStyledComponentsError(12,String(_this.name));};this.name=name;this.id=\"sc-keyframes-\"+name;this.stringifyArgs=stringifyArgs;}var _proto=Keyframes.prototype;_proto.getName=function getName(){return this.name;};return Keyframes;}();var uppercasePattern=/([A-Z])/g;var msPattern=/^ms-/;function hyphenateStyleName(string){return string.replace(uppercasePattern,'-$1').toLowerCase().replace(msPattern,'-ms-');}function addUnitIfNeeded(name,value){if(value==null||typeof value==='boolean'||value===''){return'';}if(typeof value==='number'&&value!==0&&!(name in unitless)){return value+\"px\";}return String(value).trim();}var isFalsish=function isFalsish(chunk){return chunk===undefined||chunk===null||chunk===false||chunk==='';};var objToCssArray=function objToCssArray(obj,prevKey){var rules=[];var keys=Object.keys(obj);keys.forEach(function(key){if(!isFalsish(obj[key])){if(isPlainObject(obj[key])){rules.push.apply(rules,objToCssArray(obj[key],key));return rules;}else if(isFunction(obj[key])){rules.push(hyphenateStyleName(key)+\":\",obj[key],';');return rules;}rules.push(hyphenateStyleName(key)+\": \"+addUnitIfNeeded(key,obj[key])+\";\");}return rules;});return prevKey?[prevKey+\" {\"].concat(rules,['}']):rules;};function flatten(chunk,executionContext,styleSheet){if(Array.isArray(chunk)){var ruleSet=[];for(var i=0,len=chunk.length,result;i<len;i+=1){result=flatten(chunk[i],executionContext,styleSheet);if(result==='')continue;else if(Array.isArray(result))ruleSet.push.apply(ruleSet,result);else ruleSet.push(result);}return ruleSet;}if(isFalsish(chunk)){return'';}if(isStyledComponent(chunk)){return\".\"+chunk.styledComponentId;}if(isFunction(chunk)){if(isStatelessFunction(chunk)&&executionContext){var _result=chunk(executionContext);if(process.env.NODE_ENV!=='production'&&isElement(_result)){console.warn(getComponentName(chunk)+\" is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\");}return flatten(_result,executionContext,styleSheet);}else return chunk;}if(chunk instanceof Keyframes){if(styleSheet){chunk.inject(styleSheet);return chunk.getName();}else return chunk;}return isPlainObject(chunk)?objToCssArray(chunk):chunk.toString();}function css(styles){for(var _len=arguments.length,interpolations=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){interpolations[_key-1]=arguments[_key];}if(isFunction(styles)||isPlainObject(styles)){return flatten(interleave(EMPTY_ARRAY,[styles].concat(interpolations)));}if(interpolations.length===0&&styles.length===1&&typeof styles[0]===\"string\"){return styles;}return flatten(interleave(styles,interpolations));}function constructWithOptions(componentConstructor,tag,options){if(options===void 0){options=EMPTY_OBJECT;}if(!isValidElementType(tag)){return throwStyledComponentsError(1,String(tag));}var templateFunction=function templateFunction(){return componentConstructor(tag,options,css.apply(void 0,arguments));};templateFunction.withConfig=function(config){return constructWithOptions(componentConstructor,tag,_extends({},options,{},config));};templateFunction.attrs=function(attrs){return constructWithOptions(componentConstructor,tag,_extends({},options,{attrs:Array.prototype.concat(options.attrs,attrs).filter(Boolean)}));};return templateFunction;}var isObject=function isObject(val){return typeof val==='function'||typeof val==='object'&&val!==null&&!Array.isArray(val);};var isValidKey=function isValidKey(key){return key!=='__proto__'&&key!=='constructor'&&key!=='prototype';};function mixin(target,val,key){var obj=target[key];if(isObject(val)&&isObject(obj)){mixinDeep(obj,val);}else{target[key]=val;}}function mixinDeep(target){for(var _len=arguments.length,rest=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){rest[_key-1]=arguments[_key];}for(var _i=0,_rest=rest;_i<_rest.length;_i++){var obj=_rest[_i];if(isObject(obj)){for(var key in obj){if(isValidKey(key)){mixin(target,obj[key],key);}}}}return target;}var AD_REPLACER_R=/(a)(d)/gi;var charsLength=52;var getAlphabeticChar=function getAlphabeticChar(code){return String.fromCharCode(code+(code>25?39:97));};function generateAlphabeticName(code){var name='';var x;for(x=Math.abs(code);x>charsLength;x=x/charsLength|0){name=getAlphabeticChar(x%charsLength)+name;}return(getAlphabeticChar(x%charsLength)+name).replace(AD_REPLACER_R,'$1-$2');}function isStaticRules(rules){for(var i=0;i<rules.length;i+=1){var rule=rules[i];if(isFunction(rule)&&!isStyledComponent(rule)){return false;}}return true;}var ComponentStyle=function(){function ComponentStyle(rules,componentId){this.rules=rules;this.staticRulesId='';this.isStatic=process.env.NODE_ENV==='production'&&isStaticRules(rules);this.componentId=componentId;this.baseHash=hash(componentId);StyleSheet.registerId(componentId);}var _proto=ComponentStyle.prototype;_proto.generateAndInjectStyles=function generateAndInjectStyles(executionContext,styleSheet,stylis){var componentId=this.componentId;if(this.isStatic&&!stylis.hash){if(this.staticRulesId&&styleSheet.hasNameForId(componentId,this.staticRulesId)){return this.staticRulesId;}var cssStatic=flatten(this.rules,executionContext,styleSheet).join('');var name=generateAlphabeticName(phash(this.baseHash,cssStatic.length)>>>0);if(!styleSheet.hasNameForId(componentId,name)){var cssStaticFormatted=stylis(cssStatic,\".\"+name,undefined,componentId);styleSheet.insertRules(componentId,name,cssStaticFormatted);}this.staticRulesId=name;return name;}else{var length=this.rules.length;var dynamicHash=phash(this.baseHash,stylis.hash);var css='';for(var i=0;i<length;i++){var partRule=this.rules[i];if(typeof partRule==='string'){css+=partRule;if(process.env.NODE_ENV!=='production')dynamicHash=phash(dynamicHash,partRule+i);}else{var partChunk=flatten(partRule,executionContext,styleSheet);var partString=Array.isArray(partChunk)?partChunk.join(''):partChunk;dynamicHash=phash(dynamicHash,partString+i);css+=partString;}}var _name=generateAlphabeticName(dynamicHash>>>0);if(!styleSheet.hasNameForId(componentId,_name)){var cssFormatted=stylis(css,\".\"+_name,undefined,componentId);styleSheet.insertRules(componentId,_name,cssFormatted);}return _name;}};return ComponentStyle;}();var LIMIT=200;var createWarnTooManyClasses=function createWarnTooManyClasses(displayName,componentId){var generatedClasses={};var warningSeen=false;return function(className){if(!warningSeen){generatedClasses[className]=true;if(Object.keys(generatedClasses).length>=LIMIT){var parsedIdString=componentId?\" with the id of \\\"\"+componentId+\"\\\"\":'';console.warn(\"Over \"+LIMIT+\" classes were generated for component \"+displayName+parsedIdString+\".\\n\"+'Consider using the attrs method, together with a style object for frequently changed styles.\\n'+'Example:\\n'+'  const Component = styled.div.attrs(props => ({\\n'+'    style: {\\n'+'      background: props.background,\\n'+'    },\\n'+'  }))`width: 100%;`\\n\\n'+'  <Component />');warningSeen=true;generatedClasses={};}}};};var invalidHookCallRe=/invalid hook call/i;var seen=new Set();var checkDynamicCreation=function checkDynamicCreation(displayName,componentId){if(process.env.NODE_ENV!=='production'){var parsedIdString=componentId?\" with the id of \\\"\"+componentId+\"\\\"\":'';var message=\"The component \"+displayName+parsedIdString+\" has been created dynamically.\\n\"+'You may see this warning because you\\'ve called styled inside another component.\\n'+'To resolve this only create new StyledComponents outside of any render method and function component.';try{useRef();if(!seen.has(message)){console.warn(message);seen.add(message);}}catch(error){if(invalidHookCallRe.test(error.message)){seen[\"delete\"](message);}}}};var determineTheme=function determineTheme(props,providedTheme,defaultProps){if(defaultProps===void 0){defaultProps=EMPTY_OBJECT;}return props.theme!==defaultProps.theme&&props.theme||providedTheme||defaultProps.theme;};var escapeRegex=/[[\\].#*$><+~=|^:(),\"'`-]+/g;var dashesAtEnds=/(^-|-$)/g;function escape(str){return str.replace(escapeRegex,'-').replace(dashesAtEnds,'');}function isTag(target){return typeof target==='string'&&(process.env.NODE_ENV!=='production'?target.charAt(0)===target.charAt(0).toLowerCase():true);}function generateDisplayName(target){return isTag(target)?\"styled.\"+target:\"Styled(\"+getComponentName(target)+\")\";}var generateComponentId=function generateComponentId(str){return generateAlphabeticName(hash(str)>>>0);};function joinStrings(a,b){return a&&b?a+\" \"+b:a||b;}var ThemeContext=React.createContext();var ThemeConsumer=ThemeContext.Consumer;function mergeTheme(theme,outerTheme){if(!theme){return throwStyledComponentsError(14);}if(isFunction(theme)){var mergedTheme=theme(outerTheme);if(process.env.NODE_ENV!=='production'&&(mergedTheme===null||Array.isArray(mergedTheme)||typeof mergedTheme!=='object')){return throwStyledComponentsError(7);}return mergedTheme;}if(Array.isArray(theme)||typeof theme!=='object'){return throwStyledComponentsError(8);}return outerTheme?_extends({},outerTheme,{},theme):theme;}function ThemeProvider(props){var outerTheme=useContext(ThemeContext);var themeContext=useMemo(function(){return mergeTheme(props.theme,outerTheme);},[props.theme,outerTheme]);if(!props.children){return null;}return React.createElement(ThemeContext.Provider,{value:themeContext},props.children);}var identifiers={};function generateId(displayName,parentComponentId){var name=typeof displayName!=='string'?'sc':escape(displayName);identifiers[name]=(identifiers[name]||0)+1;var componentId=name+\"-\"+generateComponentId(name+identifiers[name]);return parentComponentId?parentComponentId+\"-\"+componentId:componentId;}function useResolvedAttrs(theme,props,attrs){if(theme===void 0){theme=EMPTY_OBJECT;}var context=_extends({},props,{theme:theme});var resolvedAttrs={};attrs.forEach(function(attrDef){var resolvedAttrDef=attrDef;var key;if(isFunction(resolvedAttrDef)){resolvedAttrDef=resolvedAttrDef(context);}for(key in resolvedAttrDef){context[key]=resolvedAttrs[key]=key==='className'?joinStrings(resolvedAttrs[key],resolvedAttrDef[key]):resolvedAttrDef[key];}});return[context,resolvedAttrs];}function useInjectedStyle(componentStyle,hasAttrs,resolvedAttrs,warnTooManyClasses){var styleSheet=useStyleSheet();var stylis=useStylis();var isStatic=componentStyle.isStatic&&!hasAttrs;var className=isStatic?componentStyle.generateAndInjectStyles(EMPTY_OBJECT,styleSheet,stylis):componentStyle.generateAndInjectStyles(resolvedAttrs,styleSheet,stylis);useDebugValue(className);if(process.env.NODE_ENV!=='production'&&!isStatic&&warnTooManyClasses){warnTooManyClasses(className);}return className;}function useStyledComponentImpl(forwardedComponent,props,forwardedRef){var componentAttrs=forwardedComponent.attrs,componentStyle=forwardedComponent.componentStyle,defaultProps=forwardedComponent.defaultProps,foldedComponentIds=forwardedComponent.foldedComponentIds,shouldForwardProp=forwardedComponent.shouldForwardProp,styledComponentId=forwardedComponent.styledComponentId,target=forwardedComponent.target;useDebugValue(styledComponentId);var theme=determineTheme(props,useContext(ThemeContext),defaultProps);var _useResolvedAttrs=useResolvedAttrs(theme||EMPTY_OBJECT,props,componentAttrs),context=_useResolvedAttrs[0],attrs=_useResolvedAttrs[1];var generatedClassName=useInjectedStyle(componentStyle,componentAttrs.length>0,context,process.env.NODE_ENV!=='production'?forwardedComponent.warnTooManyClasses:undefined);var refToForward=forwardedRef;var elementToBeCreated=attrs.$as||props.$as||attrs.as||props.as||target;var isTargetTag=isTag(elementToBeCreated);var computedProps=attrs!==props?_extends({},props,{},attrs):props;var propFilterFn=shouldForwardProp||isTargetTag&&validAttr;var propsForElement={};for(var key in computedProps){if(key[0]==='$'||key==='as')continue;else if(key==='forwardedAs'){propsForElement.as=computedProps[key];}else if(!propFilterFn||propFilterFn(key,validAttr)){propsForElement[key]=computedProps[key];}}if(props.style&&attrs.style!==props.style){propsForElement.style=_extends({},props.style,{},attrs.style);}propsForElement.className=Array.prototype.concat(foldedComponentIds,styledComponentId,generatedClassName!==styledComponentId?generatedClassName:null,props.className,attrs.className).filter(Boolean).join(' ');propsForElement.ref=refToForward;return createElement(elementToBeCreated,propsForElement);}function createStyledComponent(target,options,rules){var isTargetStyledComp=isStyledComponent(target);var isCompositeComponent=!isTag(target);var _options$displayName=options.displayName,displayName=_options$displayName===void 0?generateDisplayName(target):_options$displayName,_options$componentId=options.componentId,componentId=_options$componentId===void 0?generateId(options.displayName,options.parentComponentId):_options$componentId,_options$attrs=options.attrs,attrs=_options$attrs===void 0?EMPTY_ARRAY:_options$attrs;var styledComponentId=options.displayName&&options.componentId?escape(options.displayName)+\"-\"+options.componentId:options.componentId||componentId;var finalAttrs=isTargetStyledComp&&target.attrs?Array.prototype.concat(target.attrs,attrs).filter(Boolean):attrs;var shouldForwardProp=options.shouldForwardProp;if(isTargetStyledComp&&target.shouldForwardProp){if(shouldForwardProp){shouldForwardProp=function shouldForwardProp(prop,filterFn){return target.shouldForwardProp(prop,filterFn)&&options.shouldForwardProp(prop,filterFn);};}else{shouldForwardProp=target.shouldForwardProp;}}var componentStyle=new ComponentStyle(isTargetStyledComp?target.componentStyle.rules.concat(rules):rules,styledComponentId);var WrappedStyledComponent;var forwardRef=function forwardRef(props,ref){return useStyledComponentImpl(WrappedStyledComponent,props,ref);};forwardRef.displayName=displayName;WrappedStyledComponent=React.forwardRef(forwardRef);WrappedStyledComponent.attrs=finalAttrs;WrappedStyledComponent.componentStyle=componentStyle;WrappedStyledComponent.displayName=displayName;WrappedStyledComponent.shouldForwardProp=shouldForwardProp;WrappedStyledComponent.foldedComponentIds=isTargetStyledComp?Array.prototype.concat(target.foldedComponentIds,target.styledComponentId):EMPTY_ARRAY;WrappedStyledComponent.styledComponentId=styledComponentId;WrappedStyledComponent.target=isTargetStyledComp?target.target:target;WrappedStyledComponent.withComponent=function withComponent(tag){var previousComponentId=options.componentId,optionsToCopy=_objectWithoutPropertiesLoose(options,[\"componentId\"]);var newComponentId=previousComponentId&&previousComponentId+\"-\"+(isTag(tag)?tag:escape(getComponentName(tag)));var newOptions=_extends({},optionsToCopy,{attrs:finalAttrs,componentId:newComponentId});return createStyledComponent(tag,newOptions,rules);};Object.defineProperty(WrappedStyledComponent,'defaultProps',{get:function get(){return this._foldedDefaultProps;},set:function set(obj){this._foldedDefaultProps=isTargetStyledComp?mixinDeep({},target.defaultProps,obj):obj;}});if(process.env.NODE_ENV!=='production'){checkDynamicCreation(displayName,styledComponentId);WrappedStyledComponent.warnTooManyClasses=createWarnTooManyClasses(displayName,styledComponentId);}WrappedStyledComponent.toString=function(){return\".\"+WrappedStyledComponent.styledComponentId;};if(isCompositeComponent){hoist(WrappedStyledComponent,target,{attrs:true,componentStyle:true,displayName:true,foldedComponentIds:true,shouldForwardProp:true,self:true,styledComponentId:true,target:true,withComponent:true});}return WrappedStyledComponent;}var domElements=['a','abbr','address','area','article','aside','audio','b','base','bdi','bdo','big','blockquote','body','br','button','canvas','caption','cite','code','col','colgroup','data','datalist','dd','del','details','dfn','dialog','div','dl','dt','em','embed','fieldset','figcaption','figure','footer','form','h1','h2','h3','h4','h5','h6','head','header','hgroup','hr','html','i','iframe','img','input','ins','kbd','keygen','label','legend','li','link','main','map','mark','marquee','menu','menuitem','meta','meter','nav','noscript','object','ol','optgroup','option','output','p','param','picture','pre','progress','q','rp','rt','ruby','s','samp','script','section','select','small','source','span','strong','style','sub','summary','sup','table','tbody','td','textarea','tfoot','th','thead','time','title','tr','track','u','ul','var','video','wbr','circle','clipPath','defs','ellipse','foreignObject','g','image','line','linearGradient','marker','mask','path','pattern','polygon','polyline','radialGradient','rect','stop','svg','text','tspan'];var styled=function styled(tag){return constructWithOptions(createStyledComponent,tag);};domElements.forEach(function(domElement){styled[domElement]=styled(domElement);});var GlobalStyle=function(){function GlobalStyle(rules,componentId){this.rules=rules;this.componentId=componentId;this.isStatic=isStaticRules(rules);}var _proto=GlobalStyle.prototype;_proto.createStyles=function createStyles(instance,executionContext,styleSheet,stylis){var flatCSS=flatten(this.rules,executionContext,styleSheet);var css=stylis(flatCSS.join(''),'');var id=this.componentId+instance;styleSheet.insertRules(id,id,css);};_proto.removeStyles=function removeStyles(instance,styleSheet){styleSheet.clearRules(this.componentId+instance);};_proto.renderStyles=function renderStyles(instance,executionContext,styleSheet,stylis){StyleSheet.registerId(this.componentId+instance);this.removeStyles(instance,styleSheet);this.createStyles(instance,executionContext,styleSheet,stylis);};return GlobalStyle;}();function createGlobalStyle(strings){for(var _len=arguments.length,interpolations=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){interpolations[_key-1]=arguments[_key];}var rules=css.apply(void 0,[strings].concat(interpolations));var styledComponentId=\"sc-global-\"+generateComponentId(JSON.stringify(rules));var globalStyle=new GlobalStyle(rules,styledComponentId);if(process.env.NODE_ENV!=='production'){checkDynamicCreation(styledComponentId);}function GlobalStyleComponent(props){var styleSheet=useStyleSheet();var stylis=useStylis();var theme=useContext(ThemeContext);var instanceRef=useRef(null);if(instanceRef.current===null){instanceRef.current=styleSheet.allocateGSInstance(styledComponentId);}var instance=instanceRef.current;if(process.env.NODE_ENV!=='production'&&React.Children.count(props.children)){console.warn(\"The global style component \"+styledComponentId+\" was given child JSX. createGlobalStyle does not render children.\");}if(process.env.NODE_ENV!=='production'&&rules.some(function(rule){return typeof rule==='string'&&rule.indexOf('@import')!==-1;})){console.warn(\"Please do not use @import CSS syntax in createGlobalStyle at this time, as the CSSOM APIs we use in production do not handle it well. Instead, we recommend using a library such as react-helmet to inject a typical <link> meta tag to the stylesheet, or simply embedding it manually in your index.html <head> section for a simpler app.\");}if(globalStyle.isStatic){globalStyle.renderStyles(instance,STATIC_EXECUTION_CONTEXT,styleSheet,stylis);}else{var context=_extends({},props,{theme:determineTheme(props,theme,GlobalStyleComponent.defaultProps)});globalStyle.renderStyles(instance,context,styleSheet,stylis);}useEffect(function(){return function(){return globalStyle.removeStyles(instance,styleSheet);};},EMPTY_ARRAY);return null;}return React.memo(GlobalStyleComponent);}function keyframes(strings){if(process.env.NODE_ENV!=='production'&&typeof navigator!=='undefined'&&navigator.product==='ReactNative'){console.warn('`keyframes` cannot be used on ReactNative, only on the web. To do animation in ReactNative please use Animated.');}for(var _len=arguments.length,interpolations=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){interpolations[_key-1]=arguments[_key];}var rules=css.apply(void 0,[strings].concat(interpolations)).join('');var name=generateComponentId(rules);return new Keyframes(name,[rules,name,'@keyframes']);}var ServerStyleSheet=function(){function ServerStyleSheet(){var _this=this;this._emitSheetCSS=function(){var css=_this.instance.toString();var nonce=getNonce();var attrs=[nonce&&\"nonce=\\\"\"+nonce+\"\\\"\",SC_ATTR+\"=\\\"true\\\"\",SC_ATTR_VERSION+\"=\\\"\"+SC_VERSION+\"\\\"\"];var htmlAttr=attrs.filter(Boolean).join(' ');return\"<style \"+htmlAttr+\">\"+css+\"</style>\";};this.getStyleTags=function(){if(_this.sealed){return throwStyledComponentsError(2);}return _this._emitSheetCSS();};this.getStyleElement=function(){var _props;if(_this.sealed){return throwStyledComponentsError(2);}var props=(_props={},_props[SC_ATTR]='',_props[SC_ATTR_VERSION]=SC_VERSION,_props.dangerouslySetInnerHTML={__html:_this.instance.toString()},_props);var nonce=getNonce();if(nonce){props.nonce=nonce;}return[React.createElement(\"style\",_extends({},props,{key:\"sc-0-0\"}))];};this.seal=function(){_this.sealed=true;};this.instance=new StyleSheet({isServer:true});this.sealed=false;}var _proto=ServerStyleSheet.prototype;_proto.collectStyles=function collectStyles(children){if(this.sealed){return throwStyledComponentsError(2);}return React.createElement(StyleSheetManager,{sheet:this.instance},children);};_proto.interleaveWithNodeStream=function interleaveWithNodeStream(input){{return throwStyledComponentsError(3);}};return ServerStyleSheet;}();var withTheme=function withTheme(Component){var WithTheme=React.forwardRef(function(props,ref){var theme=useContext(ThemeContext);var defaultProps=Component.defaultProps;var themeProp=determineTheme(props,theme,defaultProps);if(process.env.NODE_ENV!=='production'&&themeProp===undefined){console.warn(\"[withTheme] You are not using a ThemeProvider nor passing a theme prop or a theme in defaultProps in component class \\\"\"+getComponentName(Component)+\"\\\"\");}return React.createElement(Component,_extends({},props,{theme:themeProp,ref:ref}));});hoist(WithTheme,Component);WithTheme.displayName=\"WithTheme(\"+getComponentName(Component)+\")\";return WithTheme;};var useTheme=function useTheme(){return useContext(ThemeContext);};var __PRIVATE__={StyleSheet:StyleSheet,masterSheet:masterSheet};var version=\"5.1.0\";if(process.env.NODE_ENV!=='production'&&typeof navigator!=='undefined'&&navigator.product==='ReactNative'){console.warn(\"It looks like you've imported 'styled-components' on React Native.\\n\"+\"Perhaps you're looking to import 'styled-components/native'?\\n\"+'Read more about this at https://www.styled-components.com/docs/basics#react-native');}if(process.env.NODE_ENV!=='production'&&process.env.NODE_ENV!=='test'&&typeof window!=='undefined'){window['__styled-components-init__']=window['__styled-components-init__']||0;if(window['__styled-components-init__']===1){console.warn(\"It looks like there are several instances of 'styled-components' initialized in this application. \"+'This may cause dynamic styles not rendering properly, errors happening during rehydration process, '+'missing theme prop, and makes your application bigger without a good reason.\\n\\n'+'See https://s-c.sh/2BAXzed for more info.');}window['__styled-components-init__']+=1;}export default styled;export{ServerStyleSheet,StyleSheetConsumer,StyleSheetContext,StyleSheetManager,ThemeConsumer,ThemeContext,ThemeProvider,__PRIVATE__,createGlobalStyle,css,isStyledComponent,keyframes,useTheme,version,withTheme};","map":{"version":3,"sources":["../src/constants.js","../src/sheet/Tag.js","../src/sheet/GroupedTag.js","../src/sheet/GroupIDAllocator.js","../src/sheet/Sheet.js","../src/models/StyleSheetManager.js","../src/utils/isStaticRules.js","../src/models/ComponentStyle.js","../src/models/StyledComponent.js","../src/models/GlobalStyle.js","../src/constructors/createGlobalStyle.js","../src/models/ServerStyleSheet.js","../src/base.js"],"names":["nodes","insertRule","names","id","stylisPlugins","isCompositeComponent","flatten"],"mappings":"wvDAGgC,GAAA,CAAA,OAAA,CAAA,MAAA,CAAA,OAAA,GAAA,WAAA,GAAA,OAAA,CAAA,GAAA,CAAA,iBAAA,EAAA,OAAA,CAAA,GAAA,CAAA,OAAA,GAAA,aAAA,C,+0LCiB9B,QAAA,CAAA,QAAA,CAAA,MAAA,CAAA,C,6nBAyC8B,C,oiBAyBNA,K,CAAAA,K,EAAAA,W,mKAgBxBC,U,CAAAA,QAAAA,CAAAA,UAAAA,CAAAA,KAAAA,CAAAA,IAAAA,CAAAA,C,ucCrFA,QAAA,CAAA,iBAAA,CAAA,GAAA,CAAA,C,s7CCXiB,CAAA,GAAA,CAAA,GAAA,E,oBACA,CAAA,GAAA,CAAA,GAAA,E,8mFCmCTC,K,CAAAA,GAAAA,CAAAA,GAAAA,CAAAA,KAAAA,C,2qBA+B8BC,E,EAAAA,C,yUAkBVA,E,EAAAA,K,knGC5DiBC,a,qjLC1BM,C,2HCcnD,QAAA,CAAA,cAAA,CAAA,KAAA,CAAA,WAAA,CAAA,C,y8NC+HwB,E,ouBAuClBC,CAAAA,oBAAAA,CAAAA,CAAAA,KAAAA,CAAAA,MAAAA,C,gpIC/KN,QAAA,CAAA,WAAA,CAAA,KAAA,CAAA,WAAA,CAAA,C,sNAYkBC,OAAAA,CAAAA,KAAAA,KAAAA,CAAAA,gBAAAA,CAAAA,UAAAA,C,wCAEVH,CAAAA,EAAAA,CAAAA,KAAAA,WAAAA,CAAAA,Q,wlBCNS,CAAA,K,CAAA,IAAA,E,CAAA,CAAA,OAAA,EAAA,MAAA,CAAA,cAAA,C,grECFjB,QAAA,CAAA,gBAAA,EAAA,C,qsBAiDU,KAAA,CAAA,aAAA,CAAA,OAAA,CAAA,QAAA,CAAA,EAAA,CAAA,KAAA,CAAA,C,YAAA,CAAA,CAAA,C,ivCCzCoB,GAAA,CAAA,OAAA,CAAA,OAAA,C","sourcesContent":["// @flow\n\ndeclare var SC_DISABLE_SPEEDY: ?boolean;\ndeclare var __VERSION__: string;\n\nexport const SC_ATTR =\n  (typeof process !== 'undefined' && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR)) ||\n  'data-styled';\n\nexport const SC_ATTR_ACTIVE = 'active';\nexport const SC_ATTR_VERSION = 'data-styled-version';\nexport const SC_VERSION = __VERSION__;\nexport const SPLITTER = '/*!sc*/\\n';\n\nexport const IS_BROWSER = typeof window !== 'undefined' && 'HTMLElement' in window;\n\nexport const DISABLE_SPEEDY =\n  (typeof SC_DISABLE_SPEEDY === 'boolean' && SC_DISABLE_SPEEDY) ||\n  (typeof process !== 'undefined' &&\n    (process.env.REACT_APP_SC_DISABLE_SPEEDY || process.env.SC_DISABLE_SPEEDY)) ||\n  process.env.NODE_ENV !== 'production';\n\n// Shared empty execution context when generating static styles\nexport const STATIC_EXECUTION_CONTEXT = {};\n","// @flow\n/* eslint-disable no-use-before-define */\n\nimport { makeStyleTag, getSheet } from './dom';\nimport type { SheetOptions, Tag } from './types';\n\n/** Create a CSSStyleSheet-like tag depending on the environment */\nexport const makeTag = ({ isServer, useCSSOMInjection, target }: SheetOptions): Tag => {\n  if (isServer) {\n    return new VirtualTag(target);\n  } else if (useCSSOMInjection) {\n    return new CSSOMTag(target);\n  } else {\n    return new TextTag(target);\n  }\n};\n\nexport class CSSOMTag implements Tag {\n  element: HTMLStyleElement;\n\n  sheet: CSSStyleSheet;\n\n  length: number;\n\n  constructor(target?: HTMLElement) {\n    const element = (this.element = makeStyleTag(target));\n\n    // Avoid Edge bug where empty style elements don't create sheets\n    element.appendChild(document.createTextNode(''));\n\n    this.sheet = getSheet(element);\n    this.length = 0;\n  }\n\n  insertRule(index: number, rule: string): boolean {\n    try {\n      this.sheet.insertRule(rule, index);\n      this.length++;\n      return true;\n    } catch (_error) {\n      return false;\n    }\n  }\n\n  deleteRule(index: number): void {\n    this.sheet.deleteRule(index);\n    this.length--;\n  }\n\n  getRule(index: number): string {\n    const rule = this.sheet.cssRules[index];\n    // Avoid IE11 quirk where cssText is inaccessible on some invalid rules\n    if (rule !== undefined && typeof rule.cssText === 'string') {\n      return rule.cssText;\n    } else {\n      return '';\n    }\n  }\n}\n\n/** A Tag that emulates the CSSStyleSheet API but uses text nodes */\nexport class TextTag implements Tag {\n  element: HTMLStyleElement;\n\n  nodes: NodeList<Node>;\n\n  length: number;\n\n  constructor(target?: HTMLElement) {\n    const element = (this.element = makeStyleTag(target));\n    this.nodes = element.childNodes;\n    this.length = 0;\n  }\n\n  insertRule(index: number, rule: string): boolean {\n    if (index <= this.length && index >= 0) {\n      const node = document.createTextNode(rule);\n      const refNode = this.nodes[index];\n      this.element.insertBefore(node, refNode || null);\n      this.length++;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  deleteRule(index: number): void {\n    this.element.removeChild(this.nodes[index]);\n    this.length--;\n  }\n\n  getRule(index: number): string {\n    if (index < this.length) {\n      return this.nodes[index].textContent;\n    } else {\n      return '';\n    }\n  }\n}\n\n/** A completely virtual (server-side) Tag that doesn't manipulate the DOM */\nexport class VirtualTag implements Tag {\n  rules: string[];\n\n  length: number;\n\n  constructor(_target?: HTMLElement) {\n    this.rules = [];\n    this.length = 0;\n  }\n\n  insertRule(index: number, rule: string): boolean {\n    if (index <= this.length) {\n      this.rules.splice(index, 0, rule);\n      this.length++;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  deleteRule(index: number): void {\n    this.rules.splice(index, 1);\n    this.length--;\n  }\n\n  getRule(index: number): string {\n    if (index < this.length) {\n      return this.rules[index];\n    } else {\n      return '';\n    }\n  }\n}\n","// @flow\n/* eslint-disable no-use-before-define */\n\nimport type { GroupedTag, Tag } from './types';\nimport { SPLITTER } from '../constants';\nimport throwStyledError from '../utils/error';\n\n/** Create a GroupedTag with an underlying Tag implementation */\nexport const makeGroupedTag = (tag: Tag): GroupedTag => {\n  return new DefaultGroupedTag(tag);\n};\n\nconst BASE_SIZE = 1 << 9;\n\nclass DefaultGroupedTag implements GroupedTag {\n  groupSizes: Uint32Array;\n\n  length: number;\n\n  tag: Tag;\n\n  constructor(tag: Tag) {\n    this.groupSizes = new Uint32Array(BASE_SIZE);\n    this.length = BASE_SIZE;\n    this.tag = tag;\n  }\n\n  indexOfGroup(group: number): number {\n    let index = 0;\n    for (let i = 0; i < group; i++) {\n      index += this.groupSizes[i];\n    }\n\n    return index;\n  }\n\n  insertRules(group: number, rules: string[]): void {\n    if (group >= this.groupSizes.length) {\n      const oldBuffer = this.groupSizes;\n      const oldSize = oldBuffer.length;\n\n      let newSize = oldSize;\n      while (group >= newSize) {\n        newSize <<= 1;\n        if (newSize < 0) {\n          throwStyledError(16, `${group}`);\n        }\n      }\n\n      this.groupSizes = new Uint32Array(newSize);\n      this.groupSizes.set(oldBuffer);\n      this.length = newSize;\n\n      for (let i = oldSize; i < newSize; i++) {\n        this.groupSizes[i] = 0;\n      }\n    }\n\n    let ruleIndex = this.indexOfGroup(group + 1);\n    for (let i = 0, l = rules.length; i < l; i++) {\n      if (this.tag.insertRule(ruleIndex, rules[i])) {\n        this.groupSizes[group]++;\n        ruleIndex++;\n      }\n    }\n  }\n\n  clearGroup(group: number): void {\n    if (group < this.length) {\n      const length = this.groupSizes[group];\n      const startIndex = this.indexOfGroup(group);\n      const endIndex = startIndex + length;\n\n      this.groupSizes[group] = 0;\n\n      for (let i = startIndex; i < endIndex; i++) {\n        this.tag.deleteRule(startIndex);\n      }\n    }\n  }\n\n  getGroup(group: number): string {\n    let css = '';\n    if (group >= this.length || this.groupSizes[group] === 0) {\n      return css;\n    }\n\n    const length = this.groupSizes[group];\n    const startIndex = this.indexOfGroup(group);\n    const endIndex = startIndex + length;\n\n    for (let i = startIndex; i < endIndex; i++) {\n      css += `${this.tag.getRule(i)}${SPLITTER}`;\n    }\n\n    return css;\n  }\n}\n","// @flow\n\nimport throwStyledError from '../utils/error';\n\nconst MAX_SMI = 1 << 31 - 1;\n\nlet groupIDRegister: Map<string, number> = new Map();\nlet reverseRegister: Map<number, string> = new Map();\nlet nextFreeGroup = 1;\n\nexport const resetGroupIds = () => {\n  groupIDRegister = new Map();\n  reverseRegister = new Map();\n  nextFreeGroup = 1;\n};\n\nexport const getGroupForId = (id: string): number => {\n  if (groupIDRegister.has(id)) {\n    return (groupIDRegister.get(id): any);\n  }\n\n  const group = nextFreeGroup++;\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    ((group | 0) < 0 || group > MAX_SMI)\n  ) {\n    throwStyledError(16, `${group}`);\n  }\n\n  groupIDRegister.set(id, group);\n  reverseRegister.set(group, id);\n  return group;\n};\n\nexport const getIdForGroup = (group: number): void | string => {\n  return reverseRegister.get(group);\n};\n\nexport const setGroupForId = (id: string, group: number) => {\n  if (group >= nextFreeGroup) {\n    nextFreeGroup = group + 1;\n  }\n\n  groupIDRegister.set(id, group);\n  reverseRegister.set(group, id);\n};\n","// @flow\nimport { DISABLE_SPEEDY, IS_BROWSER } from '../constants';\nimport type { GroupedTag, Sheet, SheetOptions } from './types';\nimport { makeTag } from './Tag';\nimport { makeGroupedTag } from './GroupedTag';\nimport { getGroupForId } from './GroupIDAllocator';\nimport { outputSheet, rehydrateSheet } from './Rehydration';\n\nlet SHOULD_REHYDRATE = IS_BROWSER;\n\ntype SheetConstructorArgs = {\n  isServer?: boolean,\n  useCSSOMInjection?: boolean,\n  target?: HTMLElement,\n};\n\ntype GlobalStylesAllocationMap = { [key: string]: number };\ntype NamesAllocationMap = Map<string, Set<string>>;\n\nconst defaultOptions = {\n  isServer: !IS_BROWSER,\n  useCSSOMInjection: !DISABLE_SPEEDY,\n};\n\n/** Contains the main stylesheet logic for stringification and caching */\nexport default class StyleSheet implements Sheet {\n  gs: GlobalStylesAllocationMap;\n\n  names: NamesAllocationMap;\n\n  options: SheetOptions;\n\n  tag: void | GroupedTag;\n\n  /** Register a group ID to give it an index */\n  static registerId(id: string): number {\n    return getGroupForId(id);\n  }\n\n  constructor(\n    options: SheetConstructorArgs = defaultOptions,\n    globalStyles?: GlobalStylesAllocationMap = {},\n    names?: NamesAllocationMap\n  ) {\n    this.options = {\n      ...defaultOptions,\n      ...options,\n    };\n\n    this.gs = globalStyles;\n    this.names = new Map(names);\n\n    // We rehydrate only once and use the sheet that is created first\n    if (!this.options.isServer && IS_BROWSER && SHOULD_REHYDRATE) {\n      SHOULD_REHYDRATE = false;\n      rehydrateSheet(this);\n    }\n  }\n\n  reconstructWithOptions(options: SheetConstructorArgs) {\n    return new StyleSheet({ ...this.options, ...options }, this.gs, this.names);\n  }\n\n  allocateGSInstance(id: string) {\n    return (this.gs[id] = (this.gs[id] || 0) + 1);\n  }\n\n  /** Lazily initialises a GroupedTag for when it's actually needed */\n  getTag(): GroupedTag {\n    return this.tag || (this.tag = makeGroupedTag(makeTag(this.options)));\n  }\n\n  /** Check whether a name is known for caching */\n  hasNameForId(id: string, name: string): boolean {\n    return this.names.has(id) && (this.names.get(id): any).has(name);\n  }\n\n  /** Mark a group's name as known for caching */\n  registerName(id: string, name: string) {\n    getGroupForId(id);\n\n    if (!this.names.has(id)) {\n      const groupNames = new Set();\n      groupNames.add(name);\n      this.names.set(id, groupNames);\n    } else {\n      (this.names.get(id): any).add(name);\n    }\n  }\n\n  /** Insert new rules which also marks the name as known */\n  insertRules(id: string, name: string, rules: string[]) {\n    this.registerName(id, name);\n    this.getTag().insertRules(getGroupForId(id), rules);\n  }\n\n  /** Clears all cached names for a given group ID */\n  clearNames(id: string) {\n    if (this.names.has(id)) {\n      (this.names.get(id): any).clear();\n    }\n  }\n\n  /** Clears all rules for a given group ID */\n  clearRules(id: string) {\n    this.getTag().clearGroup(getGroupForId(id));\n    this.clearNames(id);\n  }\n\n  /** Clears the entire tag which deletes all rules but not its names */\n  clearTag() {\n    // NOTE: This does not clear the names, since it's only used during SSR\n    // so that we can continuously output only new rules\n    this.tag = undefined;\n  }\n\n  /** Outputs the current sheet as a CSS string with markers for SSR */\n  toString(): string {\n    return outputSheet(this);\n  }\n}\n","// @flow\nimport React, { useContext, useEffect, useMemo, useState, type Node, type Context } from 'react';\nimport shallowequal from 'shallowequal';\nimport StyleSheet from '../sheet';\nimport createStylisInstance, { type Stringifier } from '../utils/stylis';\n\ntype Props = {\n  children?: Node,\n  disableCSSOMInjection?: boolean,\n  disableVendorPrefixes?: boolean,\n  sheet?: StyleSheet,\n  stylisPlugins?: Array<Function>,\n  target?: HTMLElement,\n};\n\nexport const StyleSheetContext: Context<StyleSheet | void> = React.createContext();\nexport const StyleSheetConsumer = StyleSheetContext.Consumer;\nexport const StylisContext: Context<Stringifier | void> = React.createContext();\nexport const StylisConsumer = StylisContext.Consumer;\n\nexport const masterSheet: StyleSheet = new StyleSheet();\nexport const masterStylis: Stringifier = createStylisInstance();\n\nexport function useStyleSheet(): StyleSheet {\n  return useContext(StyleSheetContext) || masterSheet;\n}\n\nexport function useStylis(): Stringifier {\n  return useContext(StylisContext) || masterStylis;\n}\n\nexport default function StyleSheetManager(props: Props) {\n  const [plugins, setPlugins] = useState(props.stylisPlugins);\n  const contextStyleSheet = useStyleSheet();\n\n  const styleSheet = useMemo(() => {\n    let sheet = contextStyleSheet;\n\n    if (props.sheet) {\n      // eslint-disable-next-line prefer-destructuring\n      sheet = props.sheet;\n    } else if (props.target) {\n      sheet = sheet.reconstructWithOptions({ target: props.target });\n    }\n\n    if (props.disableCSSOMInjection) {\n      sheet = sheet.reconstructWithOptions({ useCSSOMInjection: false });\n    }\n\n    return sheet;\n  }, [props.disableCSSOMInjection, props.sheet, props.target]);\n\n  const stylis = useMemo(\n    () =>\n      createStylisInstance({\n        options: { prefix: !props.disableVendorPrefixes },\n        plugins,\n      }),\n    [props.disableVendorPrefixes, plugins]\n  );\n\n  useEffect(() => {\n    if (!shallowequal(plugins, props.stylisPlugins)) setPlugins(props.stylisPlugins);\n  }, [props.stylisPlugins]);\n\n  return (\n    <StyleSheetContext.Provider value={styleSheet}>\n      <StylisContext.Provider value={stylis}>\n        {process.env.NODE_ENV !== 'production'\n          ? React.Children.only(props.children)\n          : props.children}\n      </StylisContext.Provider>\n    </StyleSheetContext.Provider>\n  );\n}\n","// @flow\nimport isFunction from './isFunction';\nimport isStyledComponent from './isStyledComponent';\nimport type { RuleSet } from '../types';\n\nexport default function isStaticRules(rules: RuleSet): boolean {\n  for (let i = 0; i < rules.length; i += 1) {\n    const rule = rules[i];\n\n    if (isFunction(rule) && !isStyledComponent(rule)) {\n      // functions are allowed to be static if they're just being\n      // used to get the classname of a nested styled component\n      return false;\n    }\n  }\n\n  return true;\n}\n","// @flow\n\nimport flatten from '../utils/flatten';\nimport { hash, phash } from '../utils/hash';\nimport generateName from '../utils/generateAlphabeticName';\nimport isStaticRules from '../utils/isStaticRules';\nimport StyleSheet from '../sheet';\n\nimport type { RuleSet, Stringifier } from '../types';\n\n/*\n ComponentStyle is all the CSS-specific stuff, not\n the React-specific stuff.\n */\nexport default class ComponentStyle {\n  baseHash: number;\n\n  componentId: string;\n\n  isStatic: boolean;\n\n  rules: RuleSet;\n\n  staticRulesId: string;\n\n  constructor(rules: RuleSet, componentId: string) {\n    this.rules = rules;\n    this.staticRulesId = '';\n    this.isStatic = process.env.NODE_ENV === 'production' && isStaticRules(rules);\n    this.componentId = componentId;\n    this.baseHash = hash(componentId);\n\n    // NOTE: This registers the componentId, which ensures a consistent order\n    // for this component's styles compared to others\n    StyleSheet.registerId(componentId);\n  }\n\n  /*\n   * Flattens a rule set into valid CSS\n   * Hashes it, wraps the whole chunk in a .hash1234 {}\n   * Returns the hash to be injected on render()\n   * */\n  generateAndInjectStyles(executionContext: Object, styleSheet: StyleSheet, stylis: Stringifier) {\n    const { componentId } = this;\n\n    // force dynamic classnames if user-supplied stylis plugins are in use\n    if (this.isStatic && !stylis.hash) {\n      if (this.staticRulesId && styleSheet.hasNameForId(componentId, this.staticRulesId)) {\n        return this.staticRulesId;\n      }\n\n      const cssStatic = flatten(this.rules, executionContext, styleSheet).join('');\n      const name = generateName(phash(this.baseHash, cssStatic.length) >>> 0);\n\n      if (!styleSheet.hasNameForId(componentId, name)) {\n        const cssStaticFormatted = stylis(cssStatic, `.${name}`, undefined, componentId);\n\n        styleSheet.insertRules(componentId, name, cssStaticFormatted);\n      }\n\n      this.staticRulesId = name;\n\n      return name;\n    } else {\n      const { length } = this.rules;\n      let dynamicHash = phash(this.baseHash, stylis.hash);\n      let css = '';\n\n      for (let i = 0; i < length; i++) {\n        const partRule = this.rules[i];\n        if (typeof partRule === 'string') {\n          css += partRule;\n\n          if (process.env.NODE_ENV !== 'production') dynamicHash = phash(dynamicHash, partRule + i);\n        } else {\n          const partChunk = flatten(partRule, executionContext, styleSheet);\n          const partString = Array.isArray(partChunk) ? partChunk.join('') : partChunk;\n          dynamicHash = phash(dynamicHash, partString + i);\n          css += partString;\n        }\n      }\n\n      const name = generateName(dynamicHash >>> 0);\n\n      if (!styleSheet.hasNameForId(componentId, name)) {\n        const cssFormatted = stylis(css, `.${name}`, undefined, componentId);\n        styleSheet.insertRules(componentId, name, cssFormatted);\n      }\n\n      return name;\n    }\n  }\n}\n","// @flow\nimport validAttr from '@emotion/is-prop-valid';\nimport React, {\n  createElement,\n  useContext,\n  useDebugValue,\n  type AbstractComponent,\n  type Ref,\n} from 'react';\nimport hoist from 'hoist-non-react-statics';\nimport merge from '../utils/mixinDeep';\nimport ComponentStyle from './ComponentStyle';\nimport createWarnTooManyClasses from '../utils/createWarnTooManyClasses';\nimport { checkDynamicCreation } from '../utils/checkDynamicCreation';\nimport determineTheme from '../utils/determineTheme';\nimport escape from '../utils/escape';\nimport generateDisplayName from '../utils/generateDisplayName';\nimport getComponentName from '../utils/getComponentName';\nimport generateComponentId from '../utils/generateComponentId';\nimport isFunction from '../utils/isFunction';\nimport isStyledComponent from '../utils/isStyledComponent';\nimport isTag from '../utils/isTag';\nimport joinStrings from '../utils/joinStrings';\nimport { ThemeContext } from './ThemeProvider';\nimport { useStyleSheet, useStylis } from './StyleSheetManager';\nimport { EMPTY_ARRAY, EMPTY_OBJECT } from '../utils/empties';\n\nimport type { Attrs, RuleSet, Target } from '../types';\n\n/* global $Call */\n\nconst identifiers = {};\n\n/* We depend on components having unique IDs */\nfunction generateId(displayName: string, parentComponentId: string) {\n  const name = typeof displayName !== 'string' ? 'sc' : escape(displayName);\n  // Ensure that no displayName can lead to duplicate componentIds\n  identifiers[name] = (identifiers[name] || 0) + 1;\n\n  const componentId = `${name}-${generateComponentId(name + identifiers[name])}`;\n  return parentComponentId ? `${parentComponentId}-${componentId}` : componentId;\n}\n\nfunction useResolvedAttrs<Config>(theme: any = EMPTY_OBJECT, props: Config, attrs: Attrs) {\n  // NOTE: can't memoize this\n  // returns [context, resolvedAttrs]\n  // where resolvedAttrs is only the things injected by the attrs themselves\n  const context = { ...props, theme };\n  const resolvedAttrs = {};\n\n  attrs.forEach(attrDef => {\n    let resolvedAttrDef = attrDef;\n    let key;\n\n    if (isFunction(resolvedAttrDef)) {\n      resolvedAttrDef = resolvedAttrDef(context);\n    }\n\n    /* eslint-disable guard-for-in */\n    for (key in resolvedAttrDef) {\n      context[key] = resolvedAttrs[key] =\n        key === 'className'\n          ? joinStrings(resolvedAttrs[key], resolvedAttrDef[key])\n          : resolvedAttrDef[key];\n    }\n    /* eslint-enable guard-for-in */\n  });\n\n  return [context, resolvedAttrs];\n}\n\ninterface StyledComponentWrapperProperties {\n  attrs: Attrs;\n  componentStyle: ComponentStyle;\n  displayName: string;\n  foldedComponentIds: Array<string>;\n  target: Target;\n  shouldForwardProp: ?(prop: string, isValidAttr: (prop: string) => boolean) => boolean;\n  styledComponentId: string;\n  warnTooManyClasses: $Call<typeof createWarnTooManyClasses, string, string>;\n}\n\ntype StyledComponentWrapper<Config, Instance> = AbstractComponent<Config, Instance> &\n  StyledComponentWrapperProperties;\n\nfunction useInjectedStyle<T>(\n  componentStyle: ComponentStyle,\n  hasAttrs: boolean,\n  resolvedAttrs: T,\n  warnTooManyClasses?: $Call<typeof createWarnTooManyClasses, string, string>\n) {\n  const styleSheet = useStyleSheet();\n  const stylis = useStylis();\n\n  // statically styled-components don't need to build an execution context object,\n  // and shouldn't be increasing the number of class names\n  const isStatic = componentStyle.isStatic && !hasAttrs;\n\n  const className = isStatic\n    ? componentStyle.generateAndInjectStyles(EMPTY_OBJECT, styleSheet, stylis)\n    : componentStyle.generateAndInjectStyles(resolvedAttrs, styleSheet, stylis);\n\n  useDebugValue(className);\n\n  if (process.env.NODE_ENV !== 'production' && !isStatic && warnTooManyClasses) {\n    warnTooManyClasses(className);\n  }\n\n  return className;\n}\n\nfunction useStyledComponentImpl<Config: {}, Instance>(\n  forwardedComponent: StyledComponentWrapper<Config, Instance>,\n  props: Object,\n  forwardedRef: Ref<any>\n) {\n  const {\n    attrs: componentAttrs,\n    componentStyle,\n    // $FlowFixMe\n    defaultProps,\n    foldedComponentIds,\n    // $FlowFixMe\n    shouldForwardProp,\n    styledComponentId,\n    target,\n  } = forwardedComponent;\n\n  useDebugValue(styledComponentId);\n\n  // NOTE: the non-hooks version only subscribes to this when !componentStyle.isStatic,\n  // but that'd be against the rules-of-hooks. We could be naughty and do it anyway as it\n  // should be an immutable value, but behave for now.\n  const theme = determineTheme(props, useContext(ThemeContext), defaultProps);\n\n  const [context, attrs] = useResolvedAttrs(theme || EMPTY_OBJECT, props, componentAttrs);\n\n  const generatedClassName = useInjectedStyle(\n    componentStyle,\n    componentAttrs.length > 0,\n    context,\n    process.env.NODE_ENV !== 'production' ? forwardedComponent.warnTooManyClasses : undefined\n  );\n\n  const refToForward = forwardedRef;\n\n  const elementToBeCreated: Target = attrs.$as || props.$as || attrs.as || props.as || target;\n\n  const isTargetTag = isTag(elementToBeCreated);\n  const computedProps = attrs !== props ? { ...props, ...attrs } : props;\n  const propFilterFn = shouldForwardProp || (isTargetTag && validAttr);\n  const propsForElement = {};\n\n  // eslint-disable-next-line guard-for-in\n  for (const key in computedProps) {\n    if (key[0] === '$' || key === 'as') continue;\n    else if (key === 'forwardedAs') {\n      propsForElement.as = computedProps[key];\n    } else if (!propFilterFn || propFilterFn(key, validAttr)) {\n      // Don't pass through non HTML tags through to HTML elements\n      propsForElement[key] = computedProps[key];\n    }\n  }\n\n  if (props.style && attrs.style !== props.style) {\n    propsForElement.style = { ...props.style, ...attrs.style };\n  }\n\n  propsForElement.className = Array.prototype\n    .concat(\n      foldedComponentIds,\n      styledComponentId,\n      generatedClassName !== styledComponentId ? generatedClassName : null,\n      props.className,\n      attrs.className\n    )\n    .filter(Boolean)\n    .join(' ');\n\n  propsForElement.ref = refToForward;\n\n  return createElement(elementToBeCreated, propsForElement);\n}\n\nexport default function createStyledComponent(\n  target: Target | StyledComponentWrapper<*, *>,\n  options: Object,\n  rules: RuleSet\n) {\n  const isTargetStyledComp = isStyledComponent(target);\n  const isCompositeComponent = !isTag(target);\n\n  const {\n    displayName = generateDisplayName(target),\n    componentId = generateId(options.displayName, options.parentComponentId),\n    attrs = EMPTY_ARRAY,\n  } = options;\n\n  const styledComponentId =\n    options.displayName && options.componentId\n      ? `${escape(options.displayName)}-${options.componentId}`\n      : options.componentId || componentId;\n\n  // fold the underlying StyledComponent attrs up (implicit extend)\n  const finalAttrs =\n    // $FlowFixMe\n    isTargetStyledComp && target.attrs\n      ? Array.prototype.concat(target.attrs, attrs).filter(Boolean)\n      : attrs;\n\n  // eslint-disable-next-line prefer-destructuring\n  let shouldForwardProp = options.shouldForwardProp;\n\n  // $FlowFixMe\n  if (isTargetStyledComp && target.shouldForwardProp) {\n    if (shouldForwardProp) {\n      // compose nested shouldForwardProp calls\n      shouldForwardProp = (prop, filterFn) =>\n        // $FlowFixMe\n        target.shouldForwardProp(prop, filterFn) && options.shouldForwardProp(prop, filterFn);\n    } else {\n      // eslint-disable-next-line prefer-destructuring\n      shouldForwardProp = target.shouldForwardProp;\n    }\n  }\n\n  const componentStyle = new ComponentStyle(\n    isTargetStyledComp\n      ? // fold the underlying StyledComponent rules up (implicit extend)\n        // $FlowFixMe\n        target.componentStyle.rules.concat(rules)\n      : rules,\n    styledComponentId\n  );\n\n  /**\n   * forwardRef creates a new interim component, which we'll take advantage of\n   * instead of extending ParentComponent to create _another_ interim class\n   */\n  let WrappedStyledComponent;\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const forwardRef = (props, ref) => useStyledComponentImpl(WrappedStyledComponent, props, ref);\n\n  forwardRef.displayName = displayName;\n\n  // $FlowFixMe this is a forced cast to merge it StyledComponentWrapperProperties\n  WrappedStyledComponent = (React.forwardRef(forwardRef): StyledComponentWrapper<*, *>);\n\n  WrappedStyledComponent.attrs = finalAttrs;\n  WrappedStyledComponent.componentStyle = componentStyle;\n  WrappedStyledComponent.displayName = displayName;\n  WrappedStyledComponent.shouldForwardProp = shouldForwardProp;\n\n  // this static is used to preserve the cascade of static classes for component selector\n  // purposes; this is especially important with usage of the css prop\n  WrappedStyledComponent.foldedComponentIds = isTargetStyledComp\n    ? // $FlowFixMe\n      Array.prototype.concat(target.foldedComponentIds, target.styledComponentId)\n    : EMPTY_ARRAY;\n\n  WrappedStyledComponent.styledComponentId = styledComponentId;\n\n  // fold the underlying StyledComponent target up since we folded the styles\n  WrappedStyledComponent.target = isTargetStyledComp\n    ? // $FlowFixMe\n      target.target\n    : target;\n\n  // $FlowFixMe\n  WrappedStyledComponent.withComponent = function withComponent(tag: Target) {\n    const { componentId: previousComponentId, ...optionsToCopy } = options;\n\n    const newComponentId =\n      previousComponentId &&\n      `${previousComponentId}-${isTag(tag) ? tag : escape(getComponentName(tag))}`;\n\n    const newOptions = {\n      ...optionsToCopy,\n      attrs: finalAttrs,\n      componentId: newComponentId,\n    };\n\n    return createStyledComponent(tag, newOptions, rules);\n  };\n\n  // $FlowFixMe\n  Object.defineProperty(WrappedStyledComponent, 'defaultProps', {\n    get() {\n      return this._foldedDefaultProps;\n    },\n\n    set(obj) {\n      // $FlowFixMe\n      this._foldedDefaultProps = isTargetStyledComp ? merge({}, target.defaultProps, obj) : obj;\n    },\n  });\n\n  if (process.env.NODE_ENV !== 'production') {\n    checkDynamicCreation(displayName, styledComponentId);\n\n    WrappedStyledComponent.warnTooManyClasses = createWarnTooManyClasses(\n      displayName,\n      styledComponentId\n    );\n  }\n\n  // $FlowFixMe\n  WrappedStyledComponent.toString = () => `.${WrappedStyledComponent.styledComponentId}`;\n\n  if (isCompositeComponent) {\n    hoist(WrappedStyledComponent, (target: any), {\n      // all SC-specific things should not be hoisted\n      attrs: true,\n      componentStyle: true,\n      displayName: true,\n      foldedComponentIds: true,\n      shouldForwardProp: true,\n      self: true,\n      styledComponentId: true,\n      target: true,\n      withComponent: true,\n    });\n  }\n\n  return WrappedStyledComponent;\n}\n","// @flow\nimport flatten from '../utils/flatten';\nimport isStaticRules from '../utils/isStaticRules';\nimport StyleSheet from '../sheet';\n\nimport type { RuleSet, Stringifier } from '../types';\n\nexport default class GlobalStyle {\n  componentId: string;\n\n  isStatic: boolean;\n\n  rules: RuleSet;\n\n  constructor(rules: RuleSet, componentId: string) {\n    this.rules = rules;\n    this.componentId = componentId;\n    this.isStatic = isStaticRules(rules);\n  }\n\n  createStyles(\n    instance: number,\n    executionContext: Object,\n    styleSheet: StyleSheet,\n    stylis: Stringifier\n  ) {\n    const flatCSS = flatten(this.rules, executionContext, styleSheet);\n    const css = stylis(flatCSS.join(''), '');\n    const id = this.componentId + instance;\n\n    // NOTE: We use the id as a name as well, since these rules never change\n    styleSheet.insertRules(id, id, css);\n  }\n\n  removeStyles(instance: number, styleSheet: StyleSheet) {\n    styleSheet.clearRules(this.componentId + instance);\n  }\n\n  renderStyles(\n    instance: number,\n    executionContext: Object,\n    styleSheet: StyleSheet,\n    stylis: Stringifier\n  ) {\n    StyleSheet.registerId(this.componentId + instance);\n\n    // NOTE: Remove old styles, then inject the new ones\n    this.removeStyles(instance, styleSheet);\n    this.createStyles(instance, executionContext, styleSheet, stylis);\n  }\n}\n","// @flow\nimport React, { useContext, useEffect, useRef } from 'react';\nimport { STATIC_EXECUTION_CONTEXT } from '../constants';\nimport GlobalStyle from '../models/GlobalStyle';\nimport { useStyleSheet, useStylis } from '../models/StyleSheetManager';\nimport { checkDynamicCreation } from '../utils/checkDynamicCreation';\nimport determineTheme from '../utils/determineTheme';\nimport { ThemeContext } from '../models/ThemeProvider';\nimport { EMPTY_ARRAY } from '../utils/empties';\nimport generateComponentId from '../utils/generateComponentId';\nimport css from './css';\n\nimport type { Interpolation } from '../types';\n\ntype GlobalStyleComponentPropsType = Object;\n\nexport default function createGlobalStyle(\n  strings: Array<string>,\n  ...interpolations: Array<Interpolation>\n) {\n  const rules = css(strings, ...interpolations);\n  const styledComponentId = `sc-global-${generateComponentId(JSON.stringify(rules))}`;\n  const globalStyle = new GlobalStyle(rules, styledComponentId);\n\n  if (process.env.NODE_ENV !== 'production') {\n    checkDynamicCreation(styledComponentId);\n  }\n\n  function GlobalStyleComponent(props: GlobalStyleComponentPropsType) {\n    const styleSheet = useStyleSheet();\n    const stylis = useStylis();\n    const theme = useContext(ThemeContext);\n    const instanceRef = useRef(null);\n\n    if (instanceRef.current === null) {\n      instanceRef.current = styleSheet.allocateGSInstance(styledComponentId);\n    }\n\n    const instance = instanceRef.current;\n\n    if (process.env.NODE_ENV !== 'production' && React.Children.count(props.children)) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `The global style component ${styledComponentId} was given child JSX. createGlobalStyle does not render children.`\n      );\n    }\n\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      rules.some(rule => typeof rule === 'string' && rule.indexOf('@import') !== -1)\n    ) {\n      console.warn(\n        `Please do not use @import CSS syntax in createGlobalStyle at this time, as the CSSOM APIs we use in production do not handle it well. Instead, we recommend using a library such as react-helmet to inject a typical <link> meta tag to the stylesheet, or simply embedding it manually in your index.html <head> section for a simpler app.`\n      );\n    }\n\n    if (globalStyle.isStatic) {\n      globalStyle.renderStyles(instance, STATIC_EXECUTION_CONTEXT, styleSheet, stylis);\n    } else {\n      const context = {\n        ...props,\n        theme: determineTheme(props, theme, GlobalStyleComponent.defaultProps),\n      };\n\n      globalStyle.renderStyles(instance, context, styleSheet, stylis);\n    }\n\n    useEffect(() => () => globalStyle.removeStyles(instance, styleSheet), EMPTY_ARRAY);\n\n    return null;\n  }\n\n  // $FlowFixMe\n  return React.memo(GlobalStyleComponent);\n}\n","// @flow\n/* eslint-disable no-underscore-dangle */\nimport React from 'react';\nimport { IS_BROWSER, SC_ATTR, SC_ATTR_VERSION, SC_VERSION } from '../constants';\nimport throwStyledError from '../utils/error';\nimport getNonce from '../utils/nonce';\nimport StyleSheet from '../sheet';\nimport StyleSheetManager from './StyleSheetManager';\n\ndeclare var __SERVER__: boolean;\n\nconst CLOSING_TAG_R = /^\\s*<\\/[a-z]/i;\n\nexport default class ServerStyleSheet {\n  isStreaming: boolean;\n\n  instance: StyleSheet;\n\n  sealed: boolean;\n\n  constructor() {\n    this.instance = new StyleSheet({ isServer: true });\n    this.sealed = false;\n  }\n\n  _emitSheetCSS = (): string => {\n    const css = this.instance.toString();\n    const nonce = getNonce();\n    const attrs = [nonce && `nonce=\"${nonce}\"`, `${SC_ATTR}=\"true\"`, `${SC_ATTR_VERSION}=\"${SC_VERSION}\"`];\n    const htmlAttr = attrs.filter(Boolean).join(' ');\n\n    return `<style ${htmlAttr}>${css}</style>`;\n  };\n\n  collectStyles(children: any) {\n    if (this.sealed) {\n      return throwStyledError(2);\n    }\n\n    return <StyleSheetManager sheet={this.instance}>{children}</StyleSheetManager>;\n  }\n\n  getStyleTags = (): string => {\n    if (this.sealed) {\n      return throwStyledError(2);\n    }\n\n    return this._emitSheetCSS();\n  };\n\n  getStyleElement = () => {\n    if (this.sealed) {\n      return throwStyledError(2);\n    }\n\n    const props = {\n      [SC_ATTR]: '',\n      [SC_ATTR_VERSION]: SC_VERSION,\n      dangerouslySetInnerHTML: {\n        __html: this.instance.toString(),\n      },\n    };\n\n    const nonce = getNonce();\n    if (nonce) {\n      (props: any).nonce = nonce;\n    }\n\n    // v4 returned an array for this fn, so we'll do the same for v5 for backward compat\n    return [<style {...props} key=\"sc-0-0\" />];\n  };\n\n  // eslint-disable-next-line consistent-return\n  interleaveWithNodeStream(input: any) {\n    if (!__SERVER__ || IS_BROWSER) {\n      return throwStyledError(3);\n    } else if (this.sealed) {\n      return throwStyledError(2);\n    }\n\n    if (__SERVER__) {\n      this.seal();\n\n      // eslint-disable-next-line global-require\n      const { Readable, Transform } = require('stream');\n\n      const readableStream: Readable = input;\n      const { instance: sheet, _emitSheetCSS } = this;\n\n      const transformer = new Transform({\n        transform: function appendStyleChunks(chunk, /* encoding */ _, callback) {\n          // Get the chunk and retrieve the sheet's CSS as an HTML chunk,\n          // then reset its rules so we get only new ones for the next chunk\n          const renderedHtml = chunk.toString();\n          const html = _emitSheetCSS();\n\n          sheet.clearTag();\n\n          // prepend style html to chunk, unless the start of the chunk is a\n          // closing tag in which case append right after that\n          if (CLOSING_TAG_R.test(renderedHtml)) {\n            const endOfClosingTag = renderedHtml.indexOf('>') + 1;\n            const before = renderedHtml.slice(0, endOfClosingTag);\n            const after = renderedHtml.slice(endOfClosingTag);\n\n            this.push(before + html + after);\n          } else {\n            this.push(html + renderedHtml);\n          }\n\n          callback();\n        },\n      });\n\n      readableStream.on('error', err => {\n        // forward the error to the transform stream\n        transformer.emit('error', err);\n      });\n\n      return readableStream.pipe(transformer);\n    }\n  }\n\n  seal = () => {\n    this.sealed = true;\n  };\n}\n","// @flow\n\n/* Import singletons */\nimport isStyledComponent from './utils/isStyledComponent';\nimport css from './constructors/css';\nimport createGlobalStyle from './constructors/createGlobalStyle';\nimport keyframes from './constructors/keyframes';\nimport ServerStyleSheet from './models/ServerStyleSheet';\n\nimport StyleSheetManager, {\n  StyleSheetContext,\n  StyleSheetConsumer,\n} from './models/StyleSheetManager';\n\n/* Import components */\nimport ThemeProvider, { ThemeContext, ThemeConsumer } from './models/ThemeProvider';\n\n/* Import Higher Order Components */\nimport withTheme from './hoc/withTheme';\n\n/* Import hooks */\nimport useTheme from './hooks/useTheme';\n\n/* Define bundle version for export */\ndeclare var __VERSION__: string;\nconst version = __VERSION__;\n\n/* Warning if you've imported this file on React Native */\nif (\n  process.env.NODE_ENV !== 'production' &&\n  typeof navigator !== 'undefined' &&\n  navigator.product === 'ReactNative'\n) {\n  // eslint-disable-next-line no-console\n  console.warn(\n    \"It looks like you've imported 'styled-components' on React Native.\\n\" +\n      \"Perhaps you're looking to import 'styled-components/native'?\\n\" +\n      'Read more about this at https://www.styled-components.com/docs/basics#react-native'\n  );\n}\n\n/* Warning if there are several instances of styled-components */\nif (\n  process.env.NODE_ENV !== 'production' &&\n  process.env.NODE_ENV !== 'test' &&\n  typeof window !== 'undefined'\n) {\n  window['__styled-components-init__'] = window['__styled-components-init__'] || 0;\n\n  if (window['__styled-components-init__'] === 1) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      \"It looks like there are several instances of 'styled-components' initialized in this application. \" +\n        'This may cause dynamic styles not rendering properly, errors happening during rehydration process, ' +\n        'missing theme prop, and makes your application bigger without a good reason.\\n\\n' +\n        'See https://s-c.sh/2BAXzed for more info.'\n    );\n  }\n\n  window['__styled-components-init__'] += 1;\n}\n\n/* Export everything */\nexport * from './secretInternals';\nexport {\n  createGlobalStyle,\n  css,\n  isStyledComponent,\n  keyframes,\n  ServerStyleSheet,\n  StyleSheetConsumer,\n  StyleSheetContext,\n  StyleSheetManager,\n  ThemeConsumer,\n  ThemeContext,\n  ThemeProvider,\n  useTheme,\n  version,\n  withTheme,\n};\n"]},"metadata":{},"sourceType":"module"}